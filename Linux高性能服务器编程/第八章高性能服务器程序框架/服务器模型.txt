C/S客户端服c'v'h务器模型。
C/S模型的逻辑很简单， 服务器启动后，首先创建一个或者多个监听socket,并调用函数将其等待客户连接。 服务器稳定运行之后， 客户端就可以调用connect函数向服务器发起连接了。由于客户连接请求是随机到达的异步事件。 

客户端就可以调用connect函数向服务器发起连接了。

IO处理单元 请求单元  逻辑单元 请求队列 网络存储单元

C/S模型非常适合资源相对集中的场合， 并且它的实现也很简单。


阻塞和非阻塞的概念能应用于所有文件描述符。
针对非阻塞IO执行的系统调用则总是立即返回，而不管事件是否已经发生。

IO复用是最常用的IO通知机制， 它指的是， 应用程序通过IO复用函数向内核注册一组事件， 内核使用IO复用函数把其中就绪的事件通知给应用程序。

Linux常用的IO复用函数是select、 pull、 epoll_wait， 指出IO复用函数本身就是阻塞的， 它能提高程序效率的原因在于它具有同时监听多个IO事件的能力。


阻塞IO IO复用 信号驱动IO都是同步IO模型， 三种IO模型中， IO读写操作， 都是在IO事件发生之后， 由应用程序来完成。

对异步IO，用户可以直接对IO执行读写操作， 这些操作告诉内核用户读写缓存区的位置， 以及IO操作完成之后内核通知应用程序的方式， 异步IO的读写操作总是立即返回， 不论IO是否阻塞， 因为真正的读写操作由内核接管。



阻塞IO 程序阻塞于读写函数
IO复用 程序阻塞于IO复用系统调用， 但可同时监听多个IO事件， 对IO本身的读写操作是非阻塞的
SIGIO信号 信号触发读写就绪事件， 用户程序执行读写操作。程序没有阻塞阶段
异步IO  内核执行读写操作并触发读写完成事件， 程序没有阻塞阶段



两种高效的事件处理模式： 
	Reactor和Proactor
	
同步IO模型通常用于实现Reactor模式， 异步IO模型则多用于实现Proactor模式。

Reactor是这样一种模式， 它要求主线程（IO处理单元）只负责监听文件描述上是否有事件发生。有的话就立即将该事件通知工作线程。除此之外， 主线程不做任何其他实质性的工作， 读写数据， 接收新的连接， 以及处理客户请求均在工作线程中完成。
	使用同步IO模型（epoll_wait)实现Reactor模式的工作流程是：
		1. 主线程往epoll内核事件表中注册socket上的读就绪事件
		2. 主线程调用epoll_wait等待socket上有数据可读。
		3. 当socket上有数据可读时， epoll_wait通知主线程， 主线程则将socket可读事件放入请求队列
		4. 睡眠在请求队列上的某个工作线程被唤醒， 它从socket读取数据， 并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件
		5. 主线程调用epoll_wait等待socket可写
		6. 当socket可写时， epoll_wait通知主线程， 主线程将socket可写事件放入请求队列
		7. 睡眠在请求队列上的某个工作线程被唤醒， 它往socket上写入服务器处理客户请求的结果。

	在Reactor模式中， 没必要区分所谓的“读工作线程” 和 “写工作线程”

Proactor模式：
	Proactor模式把所有IO操作都交给主线程和内核来处理， 工作线程仅仅负责业务逻辑。

异步IO(使用aio_read 和aio_write)实现Proactor模式的工作流程是：
	1. 主线程调用aio_read函数向内核注册socket上的读写成事件， 并告诉内核用户读缓冲区的位置， 以及读操作完成时如何通知应用程序。
	2. 主线程继续处理其他逻辑。
	3. 当socket上的数据被读入用户缓冲区后， 内核将向应用程序发生一个信号， 以通知应用程序数据以及可用。
	4. 应用程序预先定义号的信号处理函数选择一个工作线程来处理客户请求。 工作线程处理完客户请求之后， 调用aio_write函数向内核注册socket上的写完成事件， 并告诉内核用户写缓冲区的位置， 以及写操作完成时如何通知应用程序。
	5. 主线程继续处理其他逻辑。
	6. 当用户缓冲区的数据被写入socket之后， 内核将向应用程序发送一个信号， 以通知应用程序数据已经发送完毕。
	7. 应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理， 比如决定是否关闭socket.

连接socket上的读写事件通过aio_read/aio_write向内核注册的， 因此内核将通过信号来向应用程序报告连接socket上的读写事件。 所以， 主线程的epoll_wait调用仅能用来检测监听socket上的连接请求事件吗， 而不能用来检测连接socket上的读写事件。

	同步IO模型模拟Proator工作流程：
	 1. 主线程往epoll内核事件中注册socket上的读就绪事件
	2. 主线程调用epoll_wait等待socket上有数据可读。	
	3. 当socket上有数据可读时， epoll_wait通知主线程。 主线程从socket循环读取数据， 直到没有更多数据可读， 然后将读取的数据封装成一个请求对象并插入请求队列。
	4. 睡眠在请求队列上的某个工作线程被唤醒， 它获得请求对象并处理客户请求， 然后让epoll内核事件表中注册socket上的写就绪事件。
	5. 主线程调用epoll_wait等待socket可写。
	6. 当socket可写时， epoll_wait通知主线程， 主线程往socket上写入服务器处理客户请求结果。 


并发模式是指IO处理单元和多个逻辑单元之间协调完成任务的方法。 
服务器两种并发编程模式：
	半同步/半异步模式
	领导者/追随者模式

	IO模型中， “同步” 和 “异步”区分的是内核向应用程序通知的是何种IO事件（就绪事件还是完成事件）， 以及由谁来完成读写IO.(应用程序 还是 内核)
	半同步/半异步并发模式：
		同步 指的是 程序完全按照代码序列的顺序执行；
		异步 指的是 程序的执行需要由操作系统事件来驱动


常见的系统事件包括中断、 信号等。
   同步            异步
   start	  start
		 SIGIO   
	处理其他任务 read()
		  
   read()       

被阻塞直到完成
处理读的结果        处理读的结果
   end

异步方式执行的程序相对复杂， 难于调试和扩展， 而不适合于大量的并发。
同步线程虽然效率较低， 实时性较差， 但逻辑简单。


半同步/半异步模式中：
	同步线程用于处理客户逻辑
	异步线程用于处理IO事件
异步线程监听到客户请求后， 就将其封装成请求对象并插入请求队列中， 请求队列将通知某个工作在同步模式的工作线程来读取并处理请求对象。


半同步/半反应堆：
	异步线程只有一个， 由主线程来充当， 负责监听所有socket上的事件。 
	事件处理模式是Reactor模式


领导者/追随者模式是多个工作线程轮流获得事件源集合， 轮流监听、分发并处理事件的一种模式。 
	在任意时间点， 程序都仅有一个领导者线程， 负责监听IO事件。
其他线程都是追随者， 它们休眠在线程池中等待成为新的领导者。 
  当前领导者如果检测到IO事件， 首先要从线程池中推选出新的领导者线程， 然后处理IO事件。新的领导者等待新的IO事件， 而原理的领导者则处理IO事件， 二者实现了并发。

领导者/追随者包含的组件：
	句柄集            IO资源
	线程集            所有工作线程的管理者
	事件处理器        一个或多个回调函数handle_event.
 	具体的事件处理器 

	

服务器需要注意的其他几个方面：
	池
	数据复制
	上下文切换
	锁

池是一组资源的集合， 这组资源在服务器启动之初就被完全创建好并初始化， 这称为静态资源分配。

内存池：用于socket的接收缓存和发送缓存。
连接池： 用于服务器的内部永久连接。

当两个进程之间要传递大量的数据时， 我们就应该考虑使用共享内存来在它们之间直接共享数据， 而不是用管道或者消息队列来出传递。

上下文切换： 进程切换或线程切换导致的系统开销。
























