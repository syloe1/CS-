线程并行的优点是 线程简单、直接地共享数据的潜力。

不变量--对于特定数据结构总是为真的语句。
修改线程之间共享数据的最简单的潜在问题就是破环不变量。
并发代码中错误的最常见诱因之一的例子： 竞争条件。

当竞争条件导致损坏不变量时才会出现问题。

数据竞争， 表示因单个对象的并发修改而产生的特定类型的竞争条件， 数据竞争造成可怕的未定义行为。

避免有问题的竞争条件：
	1. 最简单的选择是用保护机制封装你的数据结构， 以确保只有实际执行修改的线程能够在不变量损坏的地方看到中间数据。
	2. 修改数据结构的设计及其不变量， 从而令修改作为一系列不可分割的变更来完成， 每个修改均保留其不变量。 称为 无锁编程。

处理竞争条件的另一种方式是将对数据结构的更新作为一个事务来处理， 就如同在一个事务内完成数据库的更新一样。

如果该提交因为数据结构已被另一个线程修改而无法进行， 该事务将重新启动。 称为 软件事务内存。

C++提供的保护共享数据的最基本机制是互斥元。


互斥元也伴随自己的问题， 以死锁和保护过多或过少数据的形式。

C++通过mutex的实例创建互斥元， 调用成员函数lock()锁定，
unlock()解锁。
直接调用成员函数是不推荐 的做法， 你必须记住在离开函数的每条代码路径上都调用unlock().

C++提供了lock_guard类模板， 实现了互斥元的RAII惯用语法， 它在构造时锁定所给的互斥元， 在析构时将互斥元解锁， 从而保证被锁定的互斥元始终被正确解锁。

能够访问（并可能修改）该指针或引用的任意代码现在可以访问受保护的数据而无需锁定该互斥元。
使用互斥元保护数据需要仔细设计接口， 以确保在任意对受保护的数据进行访问之前， 互斥元已被锁定。


不要将对受保护数据的指针和引用传递到锁的范围之外， 无论是通过从函数中返回它们， 将其存放在外部可见的内存中， 还是作为参数传递给用户提供的函数。


每个线程都在等待另一个释放其互斥元。 称为死锁。


lock函数可以同时锁定两个或更多互斥元， 而且没有死锁的风险。
允许同一线程多重锁定的互斥元类型为recursive_mutex。

使用unique_lock灵活锁定

在作用域之间转移锁的所有权 
左值  实变量或对实变量的引用
右值  某种临时量

对于右值， 则所有权转移是自动的， 
对于左值， 所有权转移必须显示地完成
unique_lock就是可移动但不可复制的类型的例子


一般情况下， 只应该以执行要求操作所需的最小可能实际而去持有锁。



如果你不能在操作的整个持续时间中持有所需的锁， 你就把自己暴露在竞争条件中。



