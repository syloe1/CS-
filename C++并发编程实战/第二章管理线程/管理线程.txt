如何启动这些线程？ 怎么检查它们已经完成？
怎么监视它们？ thread对象可以管理所有事情。

启动一个线程， 等待它完成， 或是在后台运行它。

每个C++程序都拥有至少一个线程， 由C++运行时启动的， 该线程运行着main函数。

线程是通过构造thread对象来开始的， 该对象指定了线程上要运行的任务。 任务可以仅仅是一个普普通通的返回void且不接受参数的函数。这个函数在自己的线程上运行， 直到返回，然后线程停止。

void do_work();
std::thread my_thread(do_work);

你可以将一个带有函数调用操作符的类的实例传递给std::thread的构造参数来进行代替。
class background_task {
public:
	void operator() ()const {
		do_something();
		do_something_else();
	}
};
background_task f;
std::thread my_thread(f);

这种情况下， 所提供的函数对象被复制到属于新创建的执行线程的存储器中， 并从那里调用。

当给线程构造函数传递一个函数对象时要考虑的一件事是避免所谓的“C++最棘手的解析”。编译器会将其解释如下这样：
	thread my_thread(background_task());
声明了函数my_thread, 它接受单个参数， 参数类型是指向不接受参数同时返回background_task对象的函数的指针， 并返回一个thread对象。

lambda表达式基本功能是允许你编写一个局部函数， 并可能捕捉一些局部变量， 同时避免传递额外参数的需求。

一旦开始了线程， 等待它完成
	         让它自行运行

如果你不等待线程完成， 那么你需要确保该线程访问的数据是有效的， 直到该线程完成为止。



处理情况：
	1.把线程函数自包含， 并且把数据复制到该线程中， 那么原始对象就可被销毁。 仍然需要警惕包含有指针或引用的对象。
	2. 通过结合join线程， 你可以确保函数退出前， 该线程执行完毕。

等待线程完成， 通过在象关联的thread实例调用join来实现， 足以确保在函数退出之前， 即局部变量被销毁之前， 该线程就已结束。


一旦你调用了join, thread对象不再是可连接的

如果要分离线程， 通常在线程启动后可以立即调用detach。


等待线程结束， 资源获取即初始化， 提供一个类， 在它的析构函数中进行join
join后， joinable返回false

如果无需等待线程完成， 可以通过分离它避免这种异常安全问题。这打破了线程与std::thread对象的联系并确保当std::thread对象被销毁时terminate不会被调用， 即线程仍在后台运行。


分离的线程确实是在后台运行， 所有权和控制权都能被转交给C++运行时库， 以确保与线程相关联的资源在线程序退出后能被正确的回收。
被分离的线程通常称为守护线程， 



传递参数给可调用对象或函数， 基本上就是简单地将额外地参数传递给thread构造函数。
参数默认以被复制到内部存储空间， 在那里创建地执行线程可以访问它们。


这里的参数不能被复制但只能被移动， 一个对象内保存的数据被转移到另一个对象， 使原来的对象变成空壳，。 unique_ptr 提供了动态分配对象的自动内存该你了， 只有一个unqiue_ptr可以在某个时刻指向一个给定的对象， 当该实例被毁时， 其指向的对象被删除。 

移动构造函数和移动赋值运算符允许一个对象的所有权在unique_ptr实例之间进行转移。


运用move将动态对象的所有权转移到一个线程中。

void process_bid_object(unique_ptr<big_object>);
unique_ptr<big_object> p(new big_object);
p->prepare_data(42);
thread t(process_big_object, move(p));


thread实例是可移动的， 即使它们是不可复制的。 确保了在允许程序员选择在对象之间转换所有权的时候， 在任意时刻只有一个对象与某个特定的执行线程相关联。



std::ifstream 和 std::unique_ptr是可移动但不可复制的。


thread对象放到vector中是线程迈向自动管理的一步。

线程标识符是thread::id类型的， 两种获取方式
	1. 线程的标识符通过与之相关联的thread对象中通过调用get_id()成员函数来获得。
