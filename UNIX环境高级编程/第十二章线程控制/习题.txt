12.1 在Linux系统中运行图12-17中的程序，但把输出结果重定向到一个文件中，并解释结果。
12.2 实现putenv_r，即putenv的可重入版本。确保你的实现既是线程安全的，也是异步信号安全的。
12.3 是否可以通过在getenv函数开始的时候阻塞信号，并在getenv函数返回之前恢复原来的信号屏蔽字这种方法，让图12-13中的getenv函数变成异步信号安全的？解释其原因。
12.4 写一个程序练习图12-13中的getenv版本，在FreeBSD上编译并运行程序，会出现什么结果？解释其原因。
12.5 假设可以在一个程序中创建多个线程执行不同的任务，为什么还是有可能会需要用fork？解释其原因。
12.6 重新实现图10-29中的程序，在不使用nanosleep或clock_nanosleep的情况下使它成为线程安全的。
12.7 调用fork以后，是否可以通过首先用pthread_cond_destroy销毁条件变量，然后
用pthread_cond_init初始化条件变量这种方法安全地在子进程中对条件变量进行重新初始化？
12.8 图12-8中的timeout函数可以大大简化，解释其原因。