图中的文字内容如下：

14.1 编写一个测试程序说明你所用系统在下列情况下的运行情况：一个进程在试图对一个文件的某个范围加写锁的时候阻塞，之后其他进程又提出了一些相关的加读锁请求。试图加写锁的进程会不会因此而饿死？

14.2 查看你所用系统的头文件，并研究select和4个FD_宏的实现。

14.3 系统头文件通常对fd_set数据类型可以处理的最大描述符数有一个内置的限制，假设需要将描述符数增加到2048，该如何实现？

14.4 比较处理信号量集的函数（见10.11节）和处理fd_set描述符集的函数，并比较这两类函数在你系统上的实现。

14.5 用select或poll实现一个与sleep类似的函数sleep_us，不同之处是要等待指定的若干微秒。比较这个函数和BSD中的usleep函数。

14.6 是否可以利用建议性记录锁来实现图10-24中的函数TELL_WAIT、TELL_PARENT、TELL_CHILD、WAIT_PARENT以及WAIT_CHILD？如果可以，编写这些函数并测试其功能。

14.7 用非阻塞写来确定管道的容量。将其值与第2章的PIPE_BUF值进行比较。

14.8 重写图14-21中的程序来制作一个过滤器：从标准输入中读入并向标准输出写，但是要使用异步I/O接口。为了使之能正常工作，你都需要修改些什么？记住，无论你的标准输出被连接到终端、管道还是一个普通文件，都应该得到相同的结果。

14.9 回忆图14-23，在你的系统上找到一个损益平衡点，从此点开始，使用writev将快于你自己使用单个write复制数据。

14.10 运行图14-27中的程序复制一个文件，检查输入文件的上一次访问时间是否更新了？

14.11 在图14-27的程序中，在调用mmap后调用close关闭输入文件，以验证关闭描述符不会使内存映射I/O失效。


