7.1 在Intel x86系统上，使用Linux，如果执行一个输出“hello, world”的程序但不调用exit或return，则程序的返回代码为13（用shell检查），解释其原因。
7.2 图7-3中的printf函数的结果何时才被真正输出？
7.3 是否有方法不使用（a）参数传递、（b）全局变量这两种方法，将main中的参数argc和argv传递给它所调用的其他函数？
7.4 在有些UNIX系统实现中执行程序时访问不到其数据段的0单元，这是一种有意的安排，为什么？
7.5 用C语言的typedef为终止处理程序定义了一个新的数据类型Exitfunc，使用该类型修改atexit的原型。
7.6 如果用calloc分配一个long型的数组，数组的初始值是否为0？如果用calloc分配一个指针数组，数组的初始值是否为空指针？
7.7 在7.6节结尾处size命令的输出结果中，为什么没有给出堆和栈的大小？
7.8 为什么7.7节中两个文件的大小（879443和8378）不等于它们各自文本和数据大小的和？
7.9 为什么7.7节中对于一个简单的程序，使用共享库以后其可执行文件的大小变化如此巨大？
7.10 在7.10节中我们已经说明为什么不能将一个指针返回给一个自动变量，下面的程序是否正确？
int fl(int val)
{
    int num = 0;
    int *ptr = &num;
    if (val == 0) {
        num = val;
        val = 5;
        ptr = &val;
    }
    return (*ptr + 1);
}