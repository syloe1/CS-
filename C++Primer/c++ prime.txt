建议初始化每一个内置类型的变量。


extern int i //声明i而非定义i
int jp       //声明并定义jp

C++语言对分离式编译的支持
引用（reference) &d
引用必须被初始化
定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始
值拷贝给引用。一旦初始化完成，引用将和它的初始值一直绑定在
一起。

所有引用类型都要和与之绑定的对象严格匹配。
引用只能绑定在对象上， 而不能与字面值或某个表达式的计算结果绑定在一起

定义指针类型  *d, 指针存放某个对象的地址
int *p = &val;  指针的类型也要和它的对象严格匹配
*解引用对象

建议初始化所有的指针，尽量等定义了对象之后再定义指向它的指针。

把*放在const关键字之前说明指针是一个常量
const double pi = 3.14159,const double *const pip = &pi;

顶层const和底层const区别 ？

constexpr常量表达式

类型别名
typedef old new;
using old = new;

缓冲区溢出是通过下标访问不存在元素的行为

尽量使用vector和迭代器，避免使用内置数组和指针，
尽量使用string, 避免使用C风格的基于数组的字符串

当一个对象被用作右值的时候，用的是对象的值（内容）， 
对象被用作左值的时候，用的是对象的身份

不需要程序元介入的是隐式转换，
强制类型转换是非常危险的
for (int i = 0;   ; ++i) {
	内部的code必须负责终止迭代
}

for (int i  ; cin>>i; ) {
读取完所有的输入或者遇到一个输入错误

continue终止最近的循环中的当前迭代并立即开始下一次迭代

assert (expr)  if 0  exit 
			   else continue;


内联有显示内联， 隐式内联