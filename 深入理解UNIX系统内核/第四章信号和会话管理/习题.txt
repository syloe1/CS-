图中的文字内容如下：

1. 为什么信号处理函数不能跨越exec系统调用？

2. 为什么SIGCHLD信号默认情况下被忽略？

3. 如果为处于fork、exec或exit系统调用期间的进程生成一个信号，将会发生什么？

4. 在哪些情况下一个kill信号不会立即终止进程？

5. 传统的UNIX使用睡眠优先级用于两个目的：决定信号是否应该唤醒正睡眠的进程和决定进程在唤醒后的调度优先级。这种方法的缺点是什么？现代系统是如何解决这个缺点的？

6. 让信号处理函数持久存在有什么缺点（在被调用后仍保留设置状态）？有哪些信号不能拥有持久的信号处理函数？

7. 4.3BSD的sigpause调用与SVR3的有什么区别？描述一种它更有用的场景。

8. 为什么更希望由内核而不是用户来重启一个被中断的系统调用？

9. 如果进程在处理它收到的第一个信号时，又接收到多个相同信号的实例，会发生什么？对这种场景，其他语义是否会更有用？

10. 假设进程有两个未决的信号，每个信号都声明了信号处理函数。内核是如何确保进程可以在处理完第一个信号后立即处理第二个信号？

11. 进程在处理另外一个信号时收到了一个信号，会发生什么？这种场景下，进程是如何控制它的行为的？

12. 进程应该在什么时候使用SVR4的SANOCHLDWAIT功能？什么时候不应该使用它？

13. 为什么异常处理函数需要引发这个异常的进程的完整上下文内容？

14. 哪个进程可以创建一个新的进程组？（a）4.3BSD还是（b）SVR4？

15. 与4.3BSD终端和作业控制方法相比，SVR4的会话体系结构提供了哪些好处？

16. [Bell88]描述了一个用户级别的会话管理程序，可以支持登录会话。与SVR4会话体系结构相比，它有什么特点？

17. 在会话组长释放它的控制终端时，SVR4内核应该做什么？

18. SVR4是怎么允许一个会话重新连接它的控制终端的？这在哪个场景下有用？

这些内容涉及UNIX和类UNIX操作系统中的信号处理、进程管理以及会话管理等概念。