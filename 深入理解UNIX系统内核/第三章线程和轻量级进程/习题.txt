图中的文字内容如下：

1. 对下面的几个应用程序，讨论轻量级进程、用户线程，或其他编程模型是否适合它们：
   （a）分布式命名服务的服务端部分。
   （b）一个视窗系统，如Xserver。
   （c）一个运行在多处理器上且执行很多并行计算的科学应用程序。
   （d）一个只要可能就并行编译文件的make工具。

2. 在什么情况下，应用程序使用多进程比LWP或用户线程会运行得更好。

3. 为什么每个LWP需要一个单独的内核栈？系统能否通过在LWP执行系统调用时分配一个内核栈的方式来节省资源。

4. proc结构和u区包含了进程的属性和资源。在一个多线程系统上，它们的哪些字段可以被进程中的所有LWP共享，哪些必须是每个LWP私有的。

5. 假设LWP调用fork时，同一个进程里的另外一个LWP调用了exit。如果系统使用fork复制该进程的所有LWP时，会有什么结果？如果fork只复制其中一个LWP时，会有什么结果？

6. 多线程系统上的fork问题能否通过集成fork和exec的单个原子系统调用来解决？

7. 第3.3.2节描述了单一共享资源集合的问题，如文件描述符和当前目录。为什么这些资源不能属于每个LWP或每用户线程？[Bart88]进一步讨论了这个问题。

8. 标准库定义了一个每进程变量errno，包含了最后一个系统调用的错误状态。这对一个多线程的进程造成了什么问题？这个问题是如何被解决的。

9. 很多系统将库函数分为线程安全的或线程不安全的。是什么导致一个函数在被多线程应用程序使用时变得不安全？

10. 使用线程来运行中断处理函数有什么缺点？

11. 让内核控制LWP的调度有什么缺点？

12. 假设有个接口可以允许用户控制哪个LWP会被首先调度，这会导致什么问题？

13. 比较Solaris和Digital UNIX上的多线程原语，它们的优点各是什么？

请注意，这些内容是针对操作系统和多线程编程的高级问题，通常需要具备一定的计算机科学背景才能完全理解。