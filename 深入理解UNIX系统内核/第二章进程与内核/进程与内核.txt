进程是指在一个地址空间中执行单个指令系列。进程的地址空间由该进程可能引用或访问的内存位置的集合组成。
进程的控制点通过使用一个叫程序计数器的硬件寄存器来跟踪指令序列。


进程有CPU一小段时间， 然后切换到另一个进程。在这种方式中， 每个进程获得一些CPU时间来往下运行， 这种方法称为时间片。

操作系统是一个程序（内核）， 控制硬件、创建、销毁和控制所有的进程。

内核是一个特殊的程序， 可以直接运行在设备上。 它实现了进程模型和其他系统服务。 当系统启动时， 使用称为引导的特殊过程，从磁盘加载内核。 接着，内核初始化操作系统， 为进程运行设置环境。

在虚拟内存系统中， 程序使用的地址不会直接引用物理内存中的位置。 每个进程都有自己的虚拟地址空间， 通过一组地址转换映射表， 将对虚拟内存地址的引用转换为物理内存中的位置。

很多系统在以页表的方式实现这些映射， 表中的一个条目对应于进程的地址空间中的一页。  计算机的内存管理单元MMU, 通常会有一组寄存器来标识当前正在运行进程的转换映射表。

每个进程的虚拟地址空间有一个固定的部分映射为内核代码和数据结构内存， 该部分称为系统空间。

当进程发起一个系统调用时， 他会执行一个系统的指令序列让系统处于内核态， 将控制权转移给内核， 有内核代表进程来处理操作。


u区(用户区) 和 内核栈（kernel stack）是由内核管理但是一般被实现为进程地址空间中的一部分。  u区是一个数据结构， 包含了进程中内核感兴趣的信息。、

unix内核是可重入的， 意味着多个进程可以并发参与内核的活动。

内核函数可以在进程上下文或者系统上下文中执行。

当系统上下文中执行时， 内核不能访问当前进程的地址空间、U区、内核栈。 当系统上下文执行时， 内核不能被阻塞。

进程就是一个实体， 运行程序并为它提供一个可执行的环境。 进程包含一个地址空间和一个控制点。 进程是基本的调度实体， 在CPU上一次只能运行一个进程。
进程之间会竞争和占有各种系统资源。


每个进程都有一个父进程， 可能有一个或者多个子进程。

不用于那些只有在进程运行时才被处理的信号， 一个停止信号会立即改变进程状态。

上下文有五个部分组成：
	用户地址空间
	控制信息
	凭据
	环境变量
	硬件上下文


有三类时间会引发系统进入内核态： 设备中断、 异常、 陷入或软件中断


//在临界区上阻塞中断
int x = splbio();
modify disk buffer cache;
splx(x);

传统UNIX调度器使用抢占式轮转调度策略。 具有相同优先级的进程以轮转的方式被调度。
进程优先级由两个因子决定：	
	nice
	usage因子： 进程最近的CPU使用情况的度量

fork系统调用创建的新进程几乎是父进程的拷贝， 唯一的区别在于能区分二者不同的必要部分。 从fork返回后， 父子进程都执行相同的程序， 有着相同的数据段和栈区， 并继续执行紧跟fork后的指令。
	fork操作：
		1. 为子进程的数据段和栈区保留交换空间
		2. 为子进程分配新的PID和proc结构
		3. 初始化子进程的proc结构。
		4. 为子进程分配地址转换映射表
		5. 分配子进程的u区， 并从父进程复制内容
		6. 更新u区， 使其指向新的地址映射表和交换空间
		7. 将子进程加入正共享着父进程所执行程序代码段的进程组。
		8. 以每次一页的方式从父进程复制数据段和栈区， 并更新子进程组的地址映射表， 使其指向新的页
		9. 取得子进程所继承的共享资源的一些引用
		10. 通过从父进程的寄存器复制一份快照来初始化子进程的硬件上下文
		 11. 将子进程变为可运行的， 将它放入调度器队列
		 12. 将子进程的fork返回值设置为0
      		 13. 将子进程的PID返回给父进程


进程的地址空间：
	代码
	初始化数据
	未初始化数据
	共享内存
	共享库
	堆
	用户栈

当进程退出时， 它一直处于僵死状态， 直到被父进程清除。在这个装填下， 它持有的唯一资源是proc结构。
	       